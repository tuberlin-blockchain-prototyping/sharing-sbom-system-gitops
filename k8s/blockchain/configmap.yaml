apiVersion: v1
kind: ConfigMap
metadata:
  name: hardhat-config
  namespace: blockchain
data:
  package.json: |
    {
      "name": "hardhat-node",
      "version": "1.0.0",
      "devDependencies": {
        "hardhat": "^2.22.2",
        "@nomicfoundation/hardhat-toolbox": "^4.0.0",
        "@nomicfoundation/hardhat-ethers": "^3.0.0",
        "ethers": "^6.0.0"
      }
    }
  hardhat.config.js: |
    require("@nomicfoundation/hardhat-toolbox");
    
    module.exports = {
      solidity: "0.8.20",
      networks: {
        hardhat: {
          chainId: 31337,
          mining: {
            auto: true,
            interval: 0
          }
        },
        localhost: {
          url: "http://localhost:8545",
          chainId: 31337
        }
      },
      paths: {
        sources: "./contracts",
        tests: "./test",
        cache: "./cache",
        artifacts: "./artifacts"
      }
    };
  deploy.js: |
    const { ethers } = require("hardhat");
    
    async function main() {
      const [deployer] = await ethers.getSigners();
      console.log("Deploying with account:", deployer.address);
      
      const SBOMRegistryV2 = await ethers.getContractFactory("SBOMRegistryV2");
      const registry = await SBOMRegistryV2.deploy();
      await registry.waitForDeployment();
      
      const address = await registry.getAddress();
      console.log("SBOMRegistryV2 deployed to:", address);
      return address;
    }
    
    main()
      .then((address) => {
        process.stdout.write(address);
        process.exit(0);
      })
      .catch((error) => {
        console.error(error);
        process.exit(1);
      });
  SBOMRegistryV2.sol: |
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.20;
    
    contract SBOMRegistryV2 {
        struct SMTRootEntry {
            bytes32 rootHash;
            bytes32 softwareDigest;
            bytes32 sbomHash;
            string identifier;
            uint256 timestamp;
            address submitter;
        }

        struct MerkleProofEntry {
            bytes32 rootHash;
            string ipfsCid;
            bytes32 bannedListHash;
            bool compliant;
            uint256 timestamp;
            address prover;
        }

        mapping(bytes32 => SMTRootEntry) private smtRoots;
        mapping(bytes32 => MerkleProofEntry) private merkleProofs;
        
        bytes32[] private smtRootHashes;
        bytes32[] private merkleProofHashes;

        event SMTRootRegistered(
            bytes32 indexed rootHash,
            bytes32 softwareDigest,
            bytes32 sbomHash,
            string identifier,
            address indexed submitter,
            uint256 timestamp
        );

        event MerkleProofRegistered(
            bytes32 indexed rootHash,
            string ipfsCid,
            bytes32 bannedListHash,
            bool compliant,
            address indexed prover,
            uint256 timestamp
        );

        function registerSMTRoot(
            bytes32 rootHash,
            bytes32 softwareDigest,
            bytes32 sbomHash,
            string calldata identifier
        ) external {
            require(smtRoots[rootHash].timestamp == 0, "SMT root already registered");
            
            SMTRootEntry memory entry = SMTRootEntry({
                rootHash: rootHash,
                softwareDigest: softwareDigest,
                sbomHash: sbomHash,
                identifier: identifier,
                timestamp: block.timestamp,
                submitter: msg.sender
            });
            
            smtRoots[rootHash] = entry;
            smtRootHashes.push(rootHash);
            
            emit SMTRootRegistered(
                rootHash,
                softwareDigest,
                sbomHash,
                identifier,
                msg.sender,
                block.timestamp
            );
        }

        function registerMerkleProof(
            bytes32 rootHash,
            string calldata ipfsCid,
            bytes32 bannedListHash,
            bool compliant
        ) external {
            bytes32 proofKey = keccak256(abi.encodePacked(rootHash, bannedListHash));
            require(merkleProofs[proofKey].timestamp == 0, "Merkle proof already registered");
            
            MerkleProofEntry memory entry = MerkleProofEntry({
                rootHash: rootHash,
                ipfsCid: ipfsCid,
                bannedListHash: bannedListHash,
                compliant: compliant,
                timestamp: block.timestamp,
                prover: msg.sender
            });
            
            merkleProofs[proofKey] = entry;
            merkleProofHashes.push(proofKey);
            
            emit MerkleProofRegistered(
                rootHash,
                ipfsCid,
                bannedListHash,
                compliant,
                msg.sender,
                block.timestamp
            );
        }

        function getSMTRoot(bytes32 rootHash) external view returns (SMTRootEntry memory) {
            require(smtRoots[rootHash].timestamp != 0, "SMT root not found");
            return smtRoots[rootHash];
        }

        function getMerkleProof(bytes32 rootHash, bytes32 bannedListHash) external view returns (MerkleProofEntry memory) {
            bytes32 proofKey = keccak256(abi.encodePacked(rootHash, bannedListHash));
            require(merkleProofs[proofKey].timestamp != 0, "Merkle proof not found");
            return merkleProofs[proofKey];
        }

        function existsSMTRoot(bytes32 rootHash) external view returns (bool) {
            return smtRoots[rootHash].timestamp != 0;
        }

        function existsMerkleProof(bytes32 rootHash, bytes32 bannedListHash) external view returns (bool) {
            bytes32 proofKey = keccak256(abi.encodePacked(rootHash, bannedListHash));
            return merkleProofs[proofKey].timestamp != 0;
        }

        function listSMTRootHashes() external view returns (bytes32[] memory) {
            return smtRootHashes;
        }

        function listMerkleProofHashes() external view returns (bytes32[] memory) {
            return merkleProofHashes;
        }
    }
  store_smt_root.js: |
    /* eslint-disable no-console */
    const { ethers } = require("ethers");
    const hre = require("hardhat");

    async function main() {
      const address = process.env.ADDR || "0x5FbDB2315678afecb367f032d93F642f64180aa3";
      const rootHashHex = process.env.ROOT_HASH;
      const softwareDigestHex = process.env.SOFTWARE_DIGEST;
      const sbomHashHex = process.env.SBOM_HASH;
      const ident = process.env.IDENT || "local";

      if (!address || !/^0x[0-9a-fA-F]{40}$/.test(address)) {
        throw new Error(`Invalid or missing ADDR: ${address}`);
      }
      if (!rootHashHex || !/^[0-9a-fA-F]{64}$/.test(rootHashHex)) {
        throw new Error(`Invalid or missing ROOT_HASH: ${rootHashHex}`);
      }
      if (!softwareDigestHex || !/^[0-9a-fA-F]{64}$/.test(softwareDigestHex)) {
        throw new Error(`Invalid or missing SOFTWARE_DIGEST: ${softwareDigestHex}`);
      }
      if (!sbomHashHex || !/^[0-9a-fA-F]{64}$/.test(sbomHashHex)) {
        throw new Error(`Invalid or missing SBOM_HASH: ${sbomHashHex}`);
      }

      const [signer] = await hre.ethers.getSigners();
      console.log("Using signer:", signer.address);
      
      const abi = [
        "function registerSMTRoot(bytes32 rootHash, bytes32 softwareDigest, bytes32 sbomHash, string calldata identifier) external",
        "function getSMTRoot(bytes32 rootHash) external view returns (tuple(bytes32 rootHash, bytes32 softwareDigest, bytes32 sbomHash, string identifier, uint256 timestamp, address submitter))",
        "function existsSMTRoot(bytes32 rootHash) external view returns (bool)",
        "event SMTRootRegistered(bytes32 indexed rootHash, bytes32 softwareDigest, bytes32 sbomHash, string identifier, address indexed submitter, uint256 timestamp)"
      ];
      
      const contract = new ethers.Contract(address, abi, signer);
      
      const rootHashBytes32 = "0x" + rootHashHex;
      const softwareDigestBytes32 = "0x" + softwareDigestHex;
      const sbomHashBytes32 = "0x" + sbomHashHex;
      
      const exists = await contract.existsSMTRoot(rootHashBytes32);
      if (exists) {
        console.log("SMT root hash already exists in contract, skipping registration");
        console.log("Root Hash:", rootHashBytes32);
        try {
          const entry = await contract.getSMTRoot(rootHashBytes32);
          console.log("Existing entry:");
          console.log("  Software Digest:", entry.softwareDigest);
          console.log("  SBOM Hash:", entry.sbomHash);
          console.log("  Identifier:", entry.identifier);
          console.log("  Timestamp:", new Date(Number(entry.timestamp) * 1000).toISOString());
          console.log("  Submitter:", entry.submitter);
          console.log("SKIPPED");
          return;
        } catch (e) {
          console.error("Could not retrieve entry details:", e.message);
          throw new Error("SMT root hash already stored but could not retrieve details.");
        }
      }
      
      console.log("Storing SMT Root:");
      console.log("  Root Hash:", rootHashBytes32);
      console.log("  Software Digest:", softwareDigestBytes32);
      console.log("  SBOM Hash:", sbomHashBytes32);
      console.log("  Identifier:", ident);
      
      const tx = await contract.registerSMTRoot(
        rootHashBytes32,
        softwareDigestBytes32,
        sbomHashBytes32,
        ident
      );
      
      console.log("Transaction sent:", tx.hash);
      const receipt = await tx.wait();
      console.log("Transaction confirmed:", receipt.hash);
      console.log(receipt.hash);
    }

    main().catch((e) => {
      console.error(e);
      process.exit(1);
    });
  store_merkle_proof.js: |
    /* eslint-disable no-console */
    const { ethers } = require("ethers");
    const hre = require("hardhat");

    async function main() {
      const address = process.env.ADDR || "0x5FbDB2315678afecb367f032d93F642f64180aa3";
      const rootHashHex = process.env.ROOT_HASH;
      const ipfsCid = process.env.IPFS_CID;
      const bannedListHashHex = process.env.BANNED_LIST_HASH;
      const compliant = process.env.COMPLIANT === "true";

      if (!address || !/^0x[0-9a-fA-F]{40}$/.test(address)) {
        throw new Error(`Invalid or missing ADDR: ${address}`);
      }
      if (!rootHashHex || !/^[0-9a-fA-F]{64}$/.test(rootHashHex)) {
        throw new Error(`Invalid or missing ROOT_HASH: ${rootHashHex}`);
      }
      if (!ipfsCid) {
        throw new Error(`Missing IPFS_CID`);
      }
      if (!bannedListHashHex || !/^[0-9a-fA-F]{64}$/.test(bannedListHashHex)) {
        throw new Error(`Invalid or missing BANNED_LIST_HASH: ${bannedListHashHex}`);
      }

      const [signer] = await hre.ethers.getSigners();
      console.log("Using signer:", signer.address);
      
      const abi = [
        "function registerMerkleProof(bytes32 rootHash, string calldata ipfsCid, bytes32 bannedListHash, bool compliant) external",
        "function getMerkleProof(bytes32 rootHash, bytes32 bannedListHash) external view returns (tuple(bytes32 rootHash, string ipfsCid, bytes32 bannedListHash, bool compliant, uint256 timestamp, address prover))",
        "function existsMerkleProof(bytes32 rootHash, bytes32 bannedListHash) external view returns (bool)",
        "event MerkleProofRegistered(bytes32 indexed rootHash, string ipfsCid, bytes32 bannedListHash, bool compliant, address indexed prover, uint256 timestamp)"
      ];
      
      const contract = new ethers.Contract(address, abi, signer);
      
      const rootHashBytes32 = "0x" + rootHashHex;
      const bannedListHashBytes32 = "0x" + bannedListHashHex;
      
      const exists = await contract.existsMerkleProof(rootHashBytes32, bannedListHashBytes32);
      if (exists) {
        console.log("Merkle proof already exists in contract, skipping registration");
        console.log("Root Hash:", rootHashBytes32);
        console.log("Banned List Hash:", bannedListHashBytes32);
        try {
          const entry = await contract.getMerkleProof(rootHashBytes32, bannedListHashBytes32);
          console.log("Existing entry:");
          console.log("  IPFS CID:", entry.ipfsCid);
          console.log("  Compliant:", entry.compliant);
          console.log("  Timestamp:", new Date(Number(entry.timestamp) * 1000).toISOString());
          console.log("  Prover:", entry.prover);
          console.log("SKIPPED");
          return;
        } catch (e) {
          console.error("Could not retrieve entry details:", e.message);
          throw new Error("Merkle proof already stored but could not retrieve details.");
        }
      }
      
      console.log("Storing Merkle Proof:");
      console.log("  Root Hash:", rootHashBytes32);
      console.log("  IPFS CID:", ipfsCid);
      console.log("  Banned List Hash:", bannedListHashBytes32);
      console.log("  Compliant:", compliant);
      
      const tx = await contract.registerMerkleProof(
        rootHashBytes32,
        ipfsCid,
        bannedListHashBytes32,
        compliant
      );
      
      console.log("Transaction sent:", tx.hash);
      const receipt = await tx.wait();
      console.log("Transaction confirmed:", receipt.hash);
      console.log(receipt.hash);
    }

    main().catch((e) => {
      console.error(e);
      process.exit(1);
    });

